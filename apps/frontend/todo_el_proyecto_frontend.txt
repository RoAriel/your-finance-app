PROYECTO UNIFICADO - FECHA: 31/1/2026, 12:53:11
================================================


--- INICIO ARCHIVO: eslint.config.js ---

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import eslintConfigPrettier from 'eslint-config-prettier'

// --- ESTO ES NUEVO: Necesario para simular __dirname en m√≥dulos modernos ---
import { fileURLToPath } from 'url'
import { dirname } from 'path'
const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
// --------------------------------------------------------------------------

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended, eslintConfigPrettier],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      // --- ESTO ARREGLA EL ERROR DE PARSING ---
      parserOptions: {
        project: ['./tsconfig.app.json', './tsconfig.node.json'],
        tsconfigRootDir: __dirname,
      },
      // ----------------------------------------
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

--- FIN ARCHIVO: eslint.config.js ---


--- INICIO ARCHIVO: package.json ---

{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tanstack/react-query": "^5.90.20",
    "axios": "^1.13.2",
    "clsx": "^2.1.1",
    "lucide-react": "^0.563.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hot-toast": "^2.6.0",
    "react-router-dom": "^7.13.0",
    "recharts": "^3.7.0",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/postcss": "^4.1.18",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.23",
    "eslint": "^9.39.1",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "prettier": "^3.7.4",
    "tailwindcss": "^4.1.18",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4"
  }
}


--- FIN ARCHIVO: package.json ---


--- INICIO ARCHIVO: src\features\auth\hooks\useAuth.ts ---

import { useContext } from 'react';
import { AuthContext } from '../context/AuthContext';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth debe usarse dentro de un AuthProvider');
  }
  return context;
};


--- FIN ARCHIVO: src\features\auth\hooks\useAuth.ts ---


--- INICIO ARCHIVO: src\features\auth\services\auth.service.ts ---

import { api } from '../../../lib/axios';
import type { AuthResponse, LoginCredentials, RegisterDto } from '../types'; // üëà Agregamos RegisterDto
import { logger } from '../../../utils/appLogger';

export const authService = {
  login: async (credentials: LoginCredentials): Promise<AuthResponse> => {
    logger.debug('Intentando iniciar sesi√≥n', { email: credentials.email });

    const response = await api.post<AuthResponse>('/auth/login', credentials);

    if (response.data.token) {
      localStorage.setItem('token', response.data.token);
      logger.success('Login exitoso. Token guardado.');
    }

    return response.data;
  },

  // üëá NUEVO M√âTODO CON LOGGERS
  register: async (dto: RegisterDto): Promise<AuthResponse> => {
    // 1. Log de entrada (Debug)
    logger.debug('Iniciando registro de nuevo usuario', {
      email: dto.email,
      currency: dto.currency || 'ARS',
    });

    // 2. Llamada a la API
    const response = await api.post<AuthResponse>('/auth/register', dto);

    // 3. Log de √©xito
    // No guardamos el token aqu√≠ porque redirigiremos al Login,
    // pero confirmamos que el proceso termin√≥ bien.

    if (response.data.token) {
      localStorage.setItem('token', response.data.token);
      logger.success('Registro exitoso. Auto-login activado.', {
        userId: response.data.user.id,
      });
    }

    logger.success('Registro completado con √©xito', {
      email: dto.email,
      userId: response.data.user.id,
    });

    return response.data;
  },

  logout: () => {
    localStorage.removeItem('token');
    logger.info('Sesi√≥n cerrada');
    window.location.href = '/';
  },
};


--- FIN ARCHIVO: src\features\auth\services\auth.service.ts ---


--- INICIO ARCHIVO: src\features\auth\types.ts ---

// apps/frontend/src/features/auth/types.ts

export interface User {
  email: string;
  name: string;
  currency: string;
  id: string;
}

export interface AuthResponse {
  user: User;
  token: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterDto {
  name: string;
  email: string;
  password: string;
  currency?: string;
}


--- FIN ARCHIVO: src\features\auth\types.ts ---


--- INICIO ARCHIVO: src\features\budget\hooks\useBudgets.ts ---

import { useState, useEffect, useCallback } from 'react';
import { budgetsService } from '../services/budgets.service';
import type {
  Budget,
  CreateBudgetDTO,
  UpdateBudgetDTO,
} from '../services/budgets.service';

export const useBudgets = (month: number, year: number) => {
  const [budgets, setBudgets] = useState<Budget[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // 1. Cargar datos (Se ejecuta al montar y cuando cambia month/year)
  const fetchBudgets = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const data = await budgetsService.findAll(month, year);
      setBudgets(data);
    } catch (err) {
      console.error('Error fetching budgets:', err);
      setError('No se pudieron cargar los presupuestos.');
    } finally {
      setIsLoading(false);
    }
  }, [month, year]);

  // 2. Efecto disparador
  useEffect(() => {
    fetchBudgets();
  }, [fetchBudgets]);

  // --- CRUD METHODS ---

  const createBudget = async (dto: CreateBudgetDTO) => {
    try {
      const newBudget = await budgetsService.create(dto);
      // Recargamos para ver el nuevo presupuesto reflejado
      await fetchBudgets();
      return newBudget;
    } catch (err) {
      console.error('Error creating budget:', err);
      throw err;
    }
  };

  const updateBudget = async (id: string, dto: UpdateBudgetDTO) => {
    try {
      const updated = await budgetsService.update(id, dto);
      await fetchBudgets();
      return updated;
    } catch (err) {
      console.error('Error updating budget:', err);
      throw err;
    }
  };

  const deleteBudget = async (id: string) => {
    try {
      await budgetsService.delete(id);
      // Actualizamos estado local
      setBudgets((prev) => prev.filter((b) => b.id !== id));
    } catch (err) {
      console.error('Error deleting budget:', err);
      throw err;
    }
  };

  return {
    budgets,
    isLoading,
    error,
    createBudget,
    updateBudget,
    deleteBudget,
    refetch: fetchBudgets,
  };
};


--- FIN ARCHIVO: src\features\budget\hooks\useBudgets.ts ---


--- INICIO ARCHIVO: src\features\budget\services\budgets.service.ts ---

import { api } from '../../../lib/axios';

// 1. Interfaces
export interface Budget {
  id: string;
  categoryId: string;
  categoryName: string;
  month: number;
  year: number;
  amount: number;
  spent: number;
  remaining: number;
  percentage: number;
  status: 'OK' | 'WARNING' | 'EXCEEDED';
}

export interface CreateBudgetDTO {
  categoryId: string;
  amount: number;
  month: number;
  year: number;
}

export interface UpdateBudgetDTO {
  amount: number;
}

export const budgetsService = {
  // Busca presupuestos filtrando por mes y a√±o
  findAll: async (month: number, year: number): Promise<Budget[]> => {
    const params = new URLSearchParams();
    params.append('month', month.toString());
    params.append('year', year.toString());

    const { data } = await api.get<Budget[]>(`/budgets?${params.toString()}`);
    return data;
  },

  create: async (dto: CreateBudgetDTO): Promise<Budget> => {
    const { data } = await api.post<Budget>('/budgets', dto);
    return data;
  },

  // CORREGIDO: Ahora recibe el DTO completo, no solo el n√∫mero
  update: async (id: string, dto: UpdateBudgetDTO): Promise<Budget> => {
    const { data } = await api.patch<Budget>(`/budgets/${id}`, dto);
    return data;
  },

  delete: async (id: string): Promise<void> => {
    await api.delete(`/budgets/${id}`);
  },
};


--- FIN ARCHIVO: src\features\budget\services\budgets.service.ts ---


--- INICIO ARCHIVO: src\features\categories\constants.ts ---

import {
  Home,
  ShoppingCart,
  Car,
  GraduationCap,
  HeartPulse,
  Wifi,
  Coffee,
  Gift,
  Briefcase,
  PiggyBank,
  Plane,
  Gamepad2,
  Zap,
  Smartphone,
  Utensils,
} from 'lucide-react';

import type { LucideIcon } from 'lucide-react';

export const CATEGORY_COLORS = [
  '#EF4444',
  '#F97316',
  '#F59E0B',
  '#10B981',
  '#06B6D4',
  '#3B82F6',
  '#6366F1',
  '#8B5CF6',
  '#EC4899',
  '#64748B',
];

// 2. Usamos el tipo correcto en lugar de 'any'
export const ICON_MAP: Record<string, LucideIcon> = {
  Home,
  ShoppingCart,
  Car,
  GraduationCap,
  HeartPulse,
  Wifi,
  Coffee,
  Gift,
  Briefcase,
  PiggyBank,
  Plane,
  Gamepad2,
  Zap,
  Smartphone,
  Utensils,
};

export const AVAILABLE_ICONS = Object.keys(ICON_MAP);


--- FIN ARCHIVO: src\features\categories\constants.ts ---


--- INICIO ARCHIVO: src\features\categories\hooks\useCategories.ts ---

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { categoriesService } from '../services/categories.service';
import type { CreateCategoryDTO, UpdateCategoryDTO } from '../types';

export const useCategories = () => {
  const queryClient = useQueryClient();

  // 1. EL QUERY (Lo que ten√≠as antes)
  const query = useQuery({
    queryKey: ['categories'],
    queryFn: () => categoriesService.getAll(),
    // ¬°Mantenemos tu optimizaci√≥n! üöÄ
    staleTime: 1000 * 60 * 10, // 10 minutos sin volver a pedir al servidor
  });

  // 2. MUTACI√ìN: CREAR
  const createMutation = useMutation({
    mutationFn: (data: CreateCategoryDTO) => categoriesService.create(data),
    onSuccess: () => {
      // Al crear, invalidamos la cach√© para que se refresque la lista
      queryClient.invalidateQueries({ queryKey: ['categories'] });
    },
  });

  // 3. MUTACI√ìN: ACTUALIZAR
  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateCategoryDTO }) =>
      categoriesService.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
    },
  });

  // 4. MUTACI√ìN: ELIMINAR
  const deleteMutation = useMutation({
    mutationFn: (id: string) => categoriesService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['categories'] });
    },
  });

  // 5. RETORNO UNIFICADO
  return {
    // Esparcimos (...) todas las propiedades del query (data, isLoading, error, etc.)
    ...query,

    // Agregamos las funciones manuales
    createCategory: createMutation.mutateAsync,
    updateCategory: updateMutation.mutateAsync,
    deleteCategory: deleteMutation.mutateAsync,

    // (Opcional) Estados de carga espec√≠ficos de las acciones
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
  };
};


--- FIN ARCHIVO: src\features\categories\hooks\useCategories.ts ---


--- INICIO ARCHIVO: src\features\categories\services\categories.service.ts ---

import { api } from '../../../lib/axios';
import type { Category, CreateCategoryDTO, UpdateCategoryDTO } from '../types';
import type { PaginatedResponse } from '../../../types';

interface CategoryParams {
  page?: number;
  limit?: number;
  search?: string;
  [key: string]: unknown; // Permite otros filtros opcionales
}

export const categoriesService = {
  // 1. üëá Aqu√≠ est√° la magia. Definimos el retorno expl√≠cito.
  getAll: async (
    params?: CategoryParams
  ): Promise<PaginatedResponse<Category>> => {
    // Le decimos a Axios que el cuerpo de la respuesta tiene esa forma
    const { data } = await api.get<PaginatedResponse<Category>>('/categories', {
      params,
    });

    return data;
  },

  create: async (data: CreateCategoryDTO) => {
    const response = await api.post<Category>('/categories', data);
    return response.data;
  },

  update: async (id: string, data: UpdateCategoryDTO) => {
    const response = await api.patch<Category>(`/categories/${id}`, data);
    return response.data;
  },

  delete: async (id: string) => {
    await api.delete(`/categories/${id}`);
  },
};


--- FIN ARCHIVO: src\features\categories\services\categories.service.ts ---


--- INICIO ARCHIVO: src\features\categories\types.ts ---

// 1. Definimos el ENUM (Mejor que un type simple para validaciones)
export const CategoryType = {
  INCOME: 'income',
  EXPENSE: 'expense',
  BOTH: 'both',
} as const;

export type CategoryType = (typeof CategoryType)[keyof typeof CategoryType];

// 2. La Entidad (Tal como viene de la Base de Datos)
export interface Category {
  id: string;
  userId: string;
  name: string;
  type: CategoryType;
  isFixed: boolean; // true = Gasto Fijo
  color?: string; // Opcional (?) porque en Prisma es String?
  icon?: string; // Opcional (?) porque en Prisma es String?
}

// 3. DTO para Crear (Lo que env√≠a el formulario)
export interface CreateCategoryDTO {
  name: string;
  type: CategoryType;
  isFixed?: boolean; // Opcional al crear (default false en back)
  color?: string;
  icon?: string;
}

// 4. DTO para Actualizar (Partial del Create)
export type UpdateCategoryDTO = Partial<CreateCategoryDTO>;


--- FIN ARCHIVO: src\features\categories\types.ts ---


--- INICIO ARCHIVO: src\features\dashboard\hooks\useDashboardReport.ts ---

import { useQuery } from '@tanstack/react-query';
import { api } from '../../../lib/axios';
import type { DashboardReportResponse } from '../types';

interface Filters {
  month: number;
  year: number;
}

const getDashboardReport = async ({ month, year }: Filters) => {
  // Asumimos que el backend acepta query params para filtrar
  const response = await api.get<DashboardReportResponse>(
    '/reports/dashboard',
    {
      params: { month, year },
    }
  );
  return response.data;
};

export const useDashboardReport = (filters: Filters) => {
  return useQuery({
    // 1. CORRECCI√ìN DE LLAVE: Usamos 'dashboard' para coincidir con la invalidaci√≥n
    // Si prefieres 'dashboard-report', debes cambiarlo tambi√©n en useTransactions.ts
    queryKey: ['dashboard', filters],

    // 2. LOGS T√ÅCTICOS INTEGRADOS
    queryFn: async () => {
      const data = await getDashboardReport(filters);

      return data;
    },

    placeholderData: (previousData) => previousData,
  });
};


--- FIN ARCHIVO: src\features\dashboard\hooks\useDashboardReport.ts ---


--- INICIO ARCHIVO: src\features\dashboard\types.ts ---

export interface DashboardSummary {
  income: number;
  expense: number;
  cashFlow: number;
  totalAvailable: number;
}

export interface ChartData {
  categoryName: string;
  total: number;
  color: string;
}

export interface ExpensesAnalysis {
  fixed: number;
  variable: number;
}

export interface DashboardReportResponse {
  summary: DashboardSummary;
  chartData: ChartData[];
  expensesAnalysis: ExpensesAnalysis;
}


--- FIN ARCHIVO: src\features\dashboard\types.ts ---


--- INICIO ARCHIVO: src\features\savings\hooks\useSavings.ts ---

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { savingsService } from '../services/savings.service';
import type { DepositDto } from '../types';
import { api } from '../../../lib/axios';

export const useSavings = () => {
  const queryClient = useQueryClient();

  // 1. Query: Traer metas
  const query = useQuery({
    queryKey: ['savings'],
    queryFn: savingsService.getAll,
  });

  // 2. Mutation: Crear
  const createMutation = useMutation({
    mutationFn: savingsService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['savings'] });
    },
  });

  // 3. Mutation: Depositar
  const depositMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: DepositDto }) =>
      savingsService.deposit(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['savings'] });
      // Tambi√©n podr√≠amos invalidar 'transactions' si el dep√≥sito genera un gasto
    },
  });

  // 4. Mutation: Borrar
  const deleteMutation = useMutation({
    mutationFn: savingsService.delete,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['savings'] });
    },
  });

  const transferMutation = useMutation({
    mutationFn: savingsService.transfer,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['savings'] });
      // Tambi√©n invalidamos transacciones para que se refleje en los historiales
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
    },
  });

  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: any }) =>
      api.patch(`/savings/${id}`, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['savings'] });
    },
  });

  return {
    goals: query.data || [],
    isLoading: query.isLoading,
    createGoal: createMutation.mutateAsync,
    depositToGoal: depositMutation.mutateAsync,
    deleteGoal: deleteMutation.mutateAsync,
    transferGoal: transferMutation.mutateAsync,
    isTransferring: transferMutation.isPending,
    updateGoal: updateMutation.mutateAsync,
  };
};


--- FIN ARCHIVO: src\features\savings\hooks\useSavings.ts ---


--- INICIO ARCHIVO: src\features\savings\services\savings.service.ts ---

import { api } from '../../../lib/axios';
import type { TransferDto } from '../types';
import type { CreateSavingsDto, DepositDto, SavingsGoal } from '../types';

export const savingsService = {
  // Listar todas
  getAll: async () => {
    const { data } = await api.get<SavingsGoal[]>('/savings');
    return data;
  },

  // Crear nueva meta
  create: async (dto: CreateSavingsDto) => {
    const { data } = await api.post<SavingsGoal>('/savings', dto);
    return data;
  },

  // Depositar dinero (Endpoint: POST /savings/:id/deposit)
  deposit: async (id: string, dto: DepositDto) => {
    const { data } = await api.post<SavingsGoal>(`/savings/${id}/deposit`, dto);
    return data;
  },
  transfer: async (dto: TransferDto) => {
    // Asumo que tu endpoint es POST /savings/transfer (confirma si es diferente)
    const { data } = await api.post('/savings/transfer', dto);
    return data;
  },
  // Eliminar
  delete: async (id: string) => {
    await api.delete(`/savings/${id}`);
  },
};


--- FIN ARCHIVO: src\features\savings\services\savings.service.ts ---


--- INICIO ARCHIVO: src\features\savings\types.ts ---

export interface SavingsGoal {
  id: string;
  name: string;
  balance: number; // Cu√°nto tengo
  targetAmount?: number; // Cu√°nto quiero (Opcional)
  targetDate?: string; // Para cu√°ndo (Opcional)
  progress?: number; // % Calculado por backend (0-100)
  color?: string; // Hex: #FF5733
  currency: string; // ARS, USD
}

export interface CreateSavingsDto {
  name: string;
  targetAmount?: number;
  targetDate?: string;
  color?: string;
  currency?: string;
}

export interface DepositDto {
  amount: number;
  description?: string; // Opcional, por si quieres guardar el motivo
}
export interface TransferDto {
  sourceAccountId: string;
  targetAccountId: string;
  amount: number;
  description?: string;
}


--- FIN ARCHIVO: src\features\savings\types.ts ---


--- INICIO ARCHIVO: src\features\transactions\hooks\useTransactions.ts ---

import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { transactionsService } from '../services/transactions.service';
import type { CreateTransactionDTO, UpdateTransactionDTO } from '../types';
import { api } from '../../../lib/axios';
import type { PaginatedResponse } from '../../../types';
import type { Transaction } from '../types';

interface TransactionFilters {
  month?: number;
  year?: number;
  page?: number;
  limit?: number;
  search?: string;
}
export const useTransactions = (overrides?: TransactionFilters) => {
  const queryClient = useQueryClient();

  // 1. Estado local para filtros (Search, Fechas, etc.)

  const [internalFilters, setInternalFilters] = useState({
    month: new Date().getMonth() + 1,
    year: new Date().getFullYear(),
    page: 1,
    limit: 10,
    search: '',
  });

  const activeFilters = overrides || internalFilters;

  // 2. EL QUERY (Obtener datos)
  const query = useQuery({
    // La key debe incluir los filtros activos para que refresque si cambian
    queryKey: ['transactions', activeFilters],
    queryFn: async () => {
      // Construimos la URL string con los filtros activos
      const params = new URLSearchParams({
        page: activeFilters.page?.toString() || '1',
        limit: activeFilters.limit?.toString() || '10',
        month: activeFilters.month?.toString() || '',
        year: activeFilters.year?.toString() || '',
        search: activeFilters.search || '',
      });

      const { data } = await api.get<PaginatedResponse<Transaction>>(
        `/transactions?${params.toString()}`
      );
      return data;
    },
  });

  // 3. MUTACI√ìN: CREAR
  const createMutation = useMutation({
    mutationFn: (data: CreateTransactionDTO) =>
      transactionsService.create(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] }); // Actualizar gr√°ficos tambi√©n
    },
  });

  // 4. MUTACI√ìN: ACTUALIZAR
  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateTransactionDTO }) =>
      transactionsService.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    },
  });

  // 5. MUTACI√ìN: ELIMINAR (La que te faltaba)
  const deleteMutation = useMutation({
    mutationFn: (id: string) => transactionsService.delete(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    },
  });

  // 6. RETORNO UNIFICADO (Super Hook)
  return {
    // Propiedades del Query (data, isLoading, error, etc.)
    ...query,

    // Funciones de Mutaci√≥n
    createTransaction: createMutation.mutateAsync,
    updateTransaction: updateMutation.mutateAsync,
    deleteTransaction: deleteMutation.mutateAsync, // <--- ¬°Aqu√≠ est√° la magia!

    // Filtros para la UI
    filters: internalFilters,
    setFilters: setInternalFilters,

    // Estados de carga extra
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
  };
};

// Hooks auxiliares para componentes espec√≠ficos (opcional, por compatibilidad)
export const useCreateTransaction = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: transactionsService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    },
  });
};

export const useUpdateTransaction = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateTransactionDTO }) =>
      transactionsService.update(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    },
  });
};

export const useDeleteTransaction = () => {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: transactionsService.delete,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      queryClient.invalidateQueries({ queryKey: ['dashboard'] });
    },
  });
};
export const useBalance = () => {
  return useQuery({
    queryKey: ['balance'],
    queryFn: transactionsService.getBalance,
    // Opcional: refetch interval si quieres que se actualice solo
    // refetchInterval: 60000,
  });
};


--- FIN ARCHIVO: src\features\transactions\hooks\useTransactions.ts ---


--- INICIO ARCHIVO: src\features\transactions\services\transactions.service.ts ---

import { api } from '../../../lib/axios';
import type {
  TransactionsResponse,
  Transaction,
  BalanceResponse,
  CreateTransactionDTO, // <--- Importar
  UpdateTransactionDTO,
  TransactionFilters,
} from '../types';

// Definimos qu√© datos necesitamos para crear (sin ID, ni fechas, eso lo pone el back)

export const transactionsService = {
  getAll: async (filters?: TransactionFilters) => {
    // Pasamos los params en la URL para que el backend pagine
    const response = await api.get<TransactionsResponse>('/transactions', {
      params: filters,
    });
    return response.data;
  },

  create: async (data: CreateTransactionDTO) => {
    const response = await api.post<Transaction>('/transactions', data);
    return response.data;
  },

  delete: async (id: string) => {
    // Asumiendo que tu backend usa DELETE /transactions/:id
    await api.delete(`/transactions/${id}`);
  },

  getBalance: async () => {
    const response = await api.get<BalanceResponse>('/transactions/balance');
    return response.data;
  },

  update: async (id: string, data: UpdateTransactionDTO) => {
    const response = await api.patch<Transaction>(`/transactions/${id}`, data);
    return response.data;
  },
};


--- FIN ARCHIVO: src\features\transactions\services\transactions.service.ts ---


--- INICIO ARCHIVO: src\features\transactions\types.ts ---

// 1. Definimos la Categor√≠a anidada (solo lo que vemos en el JSON)
export interface TransactionCategory {
  id: string;
  name: string;
  color: string;
  icon: string;
  isFixed: boolean;
}

// 2. Definimos la Transacci√≥n
export interface Transaction {
  id: string;
  userId: string;
  type: 'income' | 'expense' | 'bouth' | 'transfer';
  amount: string; // ¬°OJO! El backend lo manda como string
  currency: string;
  description: string;
  date: string; // ISO String ("2026-01-18T...")
  categoryId: string;
  category?: TransactionCategory; // Puede venir o no, seg√∫n el backend
  createdAt: string;
}

// 3. Definimos la Paginaci√≥n (meta)
export interface PaginationMeta {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
}

// 4. La respuesta completa de la API
export interface TransactionsResponse {
  data: Transaction[];
  meta: PaginationMeta;
}

export interface BalanceResponse {
  income: number;
  expenses: number;
  balance: number;
}

export interface CreateTransactionDTO {
  amount: number;
  description: string;
  categoryId: string;
  date: string;
  type: 'income' | 'expense';
  currency: string;
}
// 6. Filtros para la consulta
export interface TransactionFilters {
  month?: number; // 1-12
  year?: number; // 2026
  page?: number;
  limit?: number;
}
// Partial hace que todos los campos de Create sean opcionales
export type UpdateTransactionDTO = Partial<CreateTransactionDTO>;


--- FIN ARCHIVO: src\features\transactions\types.ts ---


--- INICIO ARCHIVO: src\hooks\useCurrency.ts ---

import { useAuth } from '../features/auth/hooks/useAuth';

export const useCurrency = () => {
  const { user } = useAuth();

  // Moneda del usuario o ARS por defecto
  const currency = user?.currency || 'ARS';

  const format = (amount: number) => {
    return new Intl.NumberFormat('es-AR', {
      style: 'currency',
      currency: currency,
      minimumFractionDigits: 2,
    }).format(amount);
  };

  return { currency, format };
};


--- FIN ARCHIVO: src\hooks\useCurrency.ts ---


--- INICIO ARCHIVO: src\index.css ---

@import "tailwindcss";

@theme {
  /* Definimos los colores aqu√≠. 
     Tailwind v4 crea autom√°ticamente las clases como bg-success, text-primary, etc. */
  
  --color-primary: #2563EB;
  --color-primary-hover: #1D4ED8;
  
  --color-success: #10B981;
  --color-danger: #EF4444;
  
  --color-muted: #6B7280;
  --color-background: #F3F4F6;
}

--- FIN ARCHIVO: src\index.css ---


--- INICIO ARCHIVO: src\lib\axios.ts ---

import axios, { AxiosError } from 'axios';
import type { InternalAxiosRequestConfig } from 'axios';
import { logger } from '../utils/appLogger';

// 1. Crear instancia base
export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  // Timeout de 10 segundos para no dejar la UI colgada eternamente
  timeout: 30000,
});

// 2. Interceptor de REQUEST (Salida)
// Se ejecuta ANTES de que la petici√≥n salga hacia el backend
api.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    // Aqu√≠ recuperaremos el token (m√°s adelante lo conectaremos con AuthStore)
    const token = localStorage.getItem('token');

    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    logger.debug(`üöÄ Request: ${config.method?.toUpperCase()} ${config.url}`);
    return config;
  },
  (error) => {
    logger.error('Error configurando request', error);
    return Promise.reject(error);
  }
);

// 3. Interceptor de RESPONSE (Entrada)
// Se ejecuta cuando el backend responde
api.interceptors.response.use(
  (response) => {
    logger.debug(`‚úÖ Response: ${response.status} ${response.config.url}`);
    return response;
  },
  (error: AxiosError) => {
    // Manejo global de errores
    if (error.response) {
      // El servidor respondi√≥ con un c√≥digo de error (4xx, 5xx)
      const status = error.response.status;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const data = error.response.data as any;

      logger.error(`‚ùå API Error [${status}]`, data);

      if (status === 401) {
        logger.warn(
          'Sesi√≥n expirada o token inv√°lido. Redirigiendo a login...'
        );
        // TODO: Aqu√≠ dispararemos el logout autom√°tico m√°s adelante
        // localStorage.removeItem('token');
        // window.location.href = '/login';
      }
    } else if (error.request) {
      // La petici√≥n se hizo pero no hubo respuesta (Backend ca√≠do o sin internet)
      logger.error(
        'Sin respuesta del servidor. Verifica tu conexi√≥n.',
        error.request
      );
    } else {
      logger.error('Error desconocido', error.message);
    }

    return Promise.reject(error);
  }
);


--- FIN ARCHIVO: src\lib\axios.ts ---


--- INICIO ARCHIVO: src\lib\queryClient.ts ---

import { QueryClient, MutationCache } from '@tanstack/react-query';
import toast from 'react-hot-toast';

// Helper para extraer el mensaje limpio del error que manda NestJS
const getErrorMessage = (error: any) => {
  // NestJS con class-validator a veces devuelve un array de strings
  const message = error.response?.data?.message;

  if (Array.isArray(message)) {
    return message[0]; // Ej: "El monto debe ser positivo"
  }
  if (typeof message === 'string') {
    return message; // Ej: "Saldo insuficiente"
  }
  return 'Ocurri√≥ un error inesperado';
};

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 60 * 1000, // 1 minuto
      refetchOnWindowFocus: false,
    },
  },
  // üëá AQU√ç EST√Å LA MAGIA GLOBAL
  mutationCache: new MutationCache({
    onError: (error) => {
      const msg = getErrorMessage(error);

      // Lanzamos la notificaci√≥n visual
      toast.error(msg, {
        duration: 4000,
        position: 'top-center',
        style: {
          background: '#FEF2F2', // Rojo muy suave
          color: '#991B1B', // Rojo oscuro
          border: '1px solid #F87171',
          padding: '16px',
          fontWeight: 500,
        },
        iconTheme: {
          primary: '#EF4444',
          secondary: '#FEF2F2',
        },
      });
    },
    // Opcional: Tambi√©n puedes poner un toast de √©xito global aqu√≠ si quisieras
    onSuccess: () => {
      // Lanzamos la notificaci√≥n visual de √©xito
      toast.success('Operaci√≥n exitosa', {
        duration: 4000,
        position: 'top-center',
        style: {
          background: '#F0FDF4', // Verde muy suave (Green-50)
          color: '#166534', // Verde oscuro (Green-800)
          border: '1px solid #4ADE80', // Verde vibrante (Green-400)
          padding: '16px',
          fontWeight: 500,
        },
        iconTheme: {
          primary: '#22C55E', // Verde est√°ndar (Green-500)
          secondary: '#F0FDF4', // Mismo fondo que el toast
        },
      });
    },
  }),
});


--- FIN ARCHIVO: src\lib\queryClient.ts ---


--- INICIO ARCHIVO: src\types\index.ts ---

export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
}


--- FIN ARCHIVO: src\types\index.ts ---


--- INICIO ARCHIVO: src\utils\appLogger.ts ---

type LogLevel = 'info' | 'warn' | 'error' | 'debug' | 'success';

const APP_PREFIX = '[YourFinance]';

/**
 * Logger centralizado para la aplicaci√≥n.
 * En desarrollo: Muestra logs coloridos en consola.
 * En producci√≥n: Podr√≠a filtrar debugs o enviar errores a Sentry/Datadog.
 */
export const appLogger = (level: LogLevel, message: string, data?: unknown) => {
  // En React/Vite usamos import.meta.env para saber el entorno
  const isDev = import.meta.env.DEV;

  if (!isDev && level === 'debug') return; // Silenciar debug en producci√≥n

  const timestamp = new Date().toLocaleTimeString();
  const tag = `${APP_PREFIX} ${timestamp}`;

  switch (level) {
    case 'info':
      console.info(`%c${tag} ‚ÑπÔ∏è ${message}`, 'color: #3b82f6; font-weight: bold;', data || '');
      break;
    case 'success': // Agrego un nivel 'success' visual
         console.log(`%c${tag} ‚úÖ ${message}`, 'color: #10b981; font-weight: bold;', data || '');
         break;
    case 'warn':
      console.warn(`%c${tag} ‚ö†Ô∏è ${message}`, 'color: #f59e0b; font-weight: bold;', data || '');
      break;
    case 'error':
      console.error(`%c${tag} üö® ${message}`, 'color: #ef4444; font-weight: bold;', data || '');
      break;
    case 'debug':
      console.debug(`%c${tag} üêõ`, 'color: #ec4899;', message, data || '');
      break;
  }
};

// Sobrecarga para facilitar el uso (alias)
export const logger = {
  info: (msg: string, data?: unknown) => appLogger('info', msg, data),
  success: (msg: string, data?: unknown) => appLogger('success' as LogLevel, msg, data), // Hack de tipado seguro
  warn: (msg: string, data?: unknown) => appLogger('warn', msg, data),
  error: (msg: string, data?: unknown) => appLogger('error', msg, data),
  debug: (msg: string, data?: unknown) => appLogger('debug', msg, data),
};

--- FIN ARCHIVO: src\utils\appLogger.ts ---


--- INICIO ARCHIVO: src\utils\formatters.ts ---

export const formatCurrency = (amount: string | number, currency = 'ARS') => {
  const value = typeof amount === 'string' ? parseFloat(amount) : amount;

  return new Intl.NumberFormat('es-AR', {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 2,
  }).format(value);
};

export const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  return new Intl.DateTimeFormat('es-AR', {
    day: '2-digit',
    month: 'short', // 'ene', 'feb'
    year: 'numeric',
    timeZone: 'UTC',
  }).format(date);
};


--- FIN ARCHIVO: src\utils\formatters.ts ---


--- INICIO ARCHIVO: tsconfig.app.json ---

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}


--- FIN ARCHIVO: tsconfig.app.json ---


--- INICIO ARCHIVO: tsconfig.json ---

{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}


--- FIN ARCHIVO: tsconfig.json ---


--- INICIO ARCHIVO: tsconfig.node.json ---

{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}


--- FIN ARCHIVO: tsconfig.node.json ---


--- INICIO ARCHIVO: vite.config.ts ---

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})


--- FIN ARCHIVO: vite.config.ts ---
